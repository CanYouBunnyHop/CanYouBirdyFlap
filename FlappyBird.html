<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>

<body>
    <!--bird y vel<input type="text" id="bird-y">
    <br>
    fall time <input type="text" id="fall-time"> pipe rect X <input type="text" id="pipe-x">
    -->
    Score:<input type="text" id="score"> HighScore: <input type="text" id="high-score">
    <div id="game" onmousedown="gameStateMachine.currentState.onClick(event)">
        <span class ="overlay" id="menu" style="z-index: 5;">
            CLICK TO START
        </span>
        <span id="bird-wrapper"><canvas id="bird">bird</canvas></span>
        <span class="horizontal-flex">
            <span style="visibility: hidden;" id="starting-space"></span>
            <span class="vertical-flex prototype">
                <canvas class="pipe top"></canvas>
                <canvas class="pipe gap"></canvas>
                <canvas class="pipe bot"></canvas>
            </span>
            <span class="spacing prototype"></span>
        </span>
    </div>
</body>

<script type="text/javascript">
    const gameHeight = 400
    const game = document.getElementById('game');
    const gameOffset = game.getBoundingClientRect();
    game.style.height = `${gameHeight}px`

    const menu = game.querySelector('#menu');
    function setMenuText(text=''){
        menu.innerHTML = text;
    }
    const score = {
        _score: 0,
        get score(){
            return this._score;
        },
        set score(value){
            this._score = value
            document.getElementById('score').value = value;
        },
        get highScore(){
            return window.localStorage.getItem("hs") ?? 0;
        },
        set highScore(value){
            window.localStorage.setItem("hs", value);
            document.getElementById('high-score').value = value;
        }
    }

    const physicsTimeInterval = 1;
    var fallTime = 0;
    var flapTime = 0;
    var gravity = 9;
    var prevYVel = 0;
    var flapAccel = 0;
    var flapStrength = 40;

    const pipeWidth = 40
    const pipeSpacing = 110
    const pipeGapSize = 120
    const pipeCountWithCollision = 6

    var scrollSpeed = 10
    var scrollPos = 0

    const bird = game.querySelector('#bird');

    //Drawing using canvans
    // const birdSize = 150
    // function drawBirdCollider(){
    //     const ctx = bird.getContext('2d');
    //     const offsetX = bird.width/2;
    //     const offsetY = bird.height/2;
    //     const points = [[-1, -.25],[-.75, -.5],[.75,-.5],[1,-.25],
    //                     [1,.25],[.75,.5],[-.75,.5],[-1,.25]];
    //     ctx.beginPath();
    //     ctx.moveTo(points[0][0]*birdSize + offsetX, points[0][1]*birdSize + offsetY);
    //     for (var i = 1; i < points.length; i++) {
    //         ctx.lineTo(points[i][0]*birdSize + offsetX, points[i][1]*birdSize + offsetY);
    //     }
    //     ctx.closePath();
    //     ctx.lineWidth = 15;
    //     ctx.stroke();

    //     // Optional: Fill the polygon
    //     //ctx.fillStyle = 'orange';
    //     //ctx.fill();
    // }
    // drawBirdCollider();
    const scrollParent = game.querySelector('.horizontal-flex');
    //define globalThis property getter, this seem to be the most elegant way of doing it 
    Object.defineProperty(globalThis, "scrollItems",{
        get(){//spread operator converts HTMLCollection to array, so array.slice() can be used
            return [...scrollParent.children].slice(3);//0=starting space, 1=pipe, 2=space
        }
    });
    Object.defineProperty(globalThis, "scrollItemPipes",{
        get(){
            return scrollItems.filter((el, index) => index%2===0);
        }
    });

    const startingSpaceWidth = 50
    const startingSpace = scrollParent.querySelector('#starting-space');
    startingSpace.style.minWidth = `${startingSpaceWidth}%`;

    const protoPipe = scrollParent.querySelector('.vertical-flex.prototype');
    protoPipe.style.minWidth = `${pipeWidth}px`; //set width
    const protoSpacing = scrollParent.querySelector('.spacing.prototype');

    //Prototype of state and statemachine
    const baseState = {
        enterState : ()=>{},
        duringState : ()=>{},
        exitState : ()=>{},
    }
    function BaseState(enterState=()=>{} , duringState=()=>{}, exitState=()=>{}){
        this.enterState = enterState;
        this.duringState = duringState;
        this.exitState = exitState;
    }
    const baseStateMachine ={
        _state: Object.create(baseState),
        get currentState(){
            return this._state;
        },
        set currentState(targetState){
            if(this._state === targetState) return; //return if targetState is exactly the same 
            let curState = this._state;
            curState.exitState();
            targetState.enterState();
            this._state = targetState;
        }
    };
    function AABBCollision(a, b=bird, exitCallBack=()=>{}){
        let rectA = a.getBoundingClientRect();
        let rectB = b.getBoundingClientRect();
        let xOverlap = (rectA.right >= rectB.left) && (rectA.left <= rectB.right);
        let yOverlap = (rectA.bottom >= rectB.top) && (rectA.top <= rectB.bottom);
        if(xOverlap && yOverlap){
            a.wasColliding = true
            return true;
        }
        if(a.wasColliding){
            exitCallBack();
            a.wasColliding = false;
            return false;
        }
        return (xOverlap && yOverlap);
    }
    const pipe = {
        top : protoPipe.querySelector('.pipe.top'),
        gap : protoPipe.querySelector('.pipe.gap'),
        bot : protoPipe.querySelector('.pipe.bot'),
    };
    function pipeElToObj(_pipe = pipe){
        return {
            top : _pipe.querySelector('.pipe.top'),
            gap : _pipe.querySelector('.pipe.gap'),
            bot : _pipe.querySelector('.pipe.bot'),
        }
    }
    function Pipe(){//pipe constructor
        let pipeClone = protoPipe.cloneNode(true); //true for deep, cloning the rest of object
        pipeClone.classList.remove('prototype'); //removes prototype class
        this.top = pipeClone.querySelector('.pipe.top');
        this.gap = pipeClone.querySelector('.pipe.gap');
        this.bot = pipeClone.querySelector('.pipe.bot');
        //randomise gap position by setting flex for top and bot
        this.gap.style.flexBasis = `${pipeGapSize}px`;
        let r =  Math.random();
        this.top.style.flex = r;
        this.bot.style.flex = 1-r;
        //create element
        pipeClone.style.display = "flex"; //unhides, default is vertical flex
        scrollParent.appendChild(pipeClone);
        scrollParent.appendChild(createSpacing());
        return pipeClone;
    }
    function createSpacing(){
        let spaceClone = protoSpacing.cloneNode(false);
        spaceClone.classList.remove('prototype'); 
        spaceClone.style.minWidth = `${pipeSpacing}px`;
        spaceClone.style.display = 'block';
        return spaceClone;
    }
    function createPipes(pipeCount = 20)
    {
        for(let i=0; i<pipeCount; i++){//create pipes
            new Pipe();
        }
    }
    function removeFirstScrollItem(){
        var w = scrollItems[0].offsetWidth + startingSpace.offsetWidth;
        startingSpace.style.minWidth = `${w}px`; //adding width to empty space, next item wont snap to the left
        scrollItems[0].remove();
    }
    function clamp(min, max, ref){
        return Math.max(Math.min(ref, max), min);
    }
    var curYVelocity = () => {
        let flapAccel = -flapStrength*clamp(0,1,flapTime);
        let accel = (gravity*(fallTime / 10)) + flapAccel;//gravity + flap
        let result = clamp(-10, gameHeight, prevYVel+accel);//clamp result so bird stays inside
        prevYVel = result;
        return result;
    }
    const baseGameState = {
        __proto__ : baseState, //inherit base state object
        onClick : (event)=>{},
    };
    function BaseGameState(enterState=()=>{}, duringState=()=>{},exitState=()=>{}, onClick=(event)=>{}){//Base State constructor
        this.enterState = enterState;
        this.duringState = duringState;
        this.exitState = exitState;
        this.onClick = onClick;
    }
    const gameStateMachine={
        __proto__: baseStateMachine,
        _state: new BaseGameState(),
    };
    const gameState = {
        clickStart : new BaseGameState(
            function(){//Enter
                menu.innerHTML = 'CLICK TO START';
                menu.style.visibility = 'visible';
                document.getElementById('high-score').value = score.highScore;
            },
            function(){//During
            }, 
            function(){//Exit
            },
            function(event){//onClick
                gameStateMachine.currentState = gameState.play;
            }),
        play : new BaseGameState(
            function(){//Enter
                menu.style.visibility = 'hidden';
                bird.style.visibility = 'visible';
                resetGame();
            },
            function(){//During
                //When pipe scroll past viewport
                if(scrollItems[0].getBoundingClientRect().right < -0){
                    removeFirstScrollItem();//remove pipe
                    removeFirstScrollItem();//remove spacing
                    new Pipe();//create new pipe and spacing
                }
                //Physics Stuff
                const delta = physicsTimeInterval/10;
                fallTime += delta;
                flapTime -= delta;
                scrollPos -= delta * scrollSpeed;
                scrollParent.style.transform = `translateX(${scrollPos}px)`;
                bird.style.transform = `translateY(${curYVelocity()}px)`;
                
                //Define how to enter gameover
                let gameBirdYPos = curYVelocity();
                for(let i = 0; i < pipeCountWithCollision; i++){
                    let p = pipeElToObj(scrollItemPipes[i]);
                    if(AABBCollision(p.top)||AABBCollision(p.bot)){
                        gameStateMachine.currentState = gameState.gameOver;
                    }
                    AABBCollision(p.gap, bird, function(){score.score++;});
                }
                if(gameBirdYPos >= gameHeight-10){gameStateMachine.currentState = gameState.gameOver;} //bird hits the ground
            }, 
            function(){//Exit
            },
            function(event){//onClick
                //-1 here so bird doesnt feel too heavy, bird will be floatier the lowers the fall time goes
                fallTime = -1; 
                flapTime = 0.3;
            }),
        gameOver : new BaseGameState(
            function(){//Enter
                game.style.pointerEvents = 'none';
                //update highscore
                if(score.score > score.highScore){
                    score.highScore = score.score;
                }
                menu.innerHTML =`SCORE : ${score.score} <br>HIGHSCORE : ${score.highScore}`;
                menu.style.visibility = 'visible';
                
                setTimeout(function(){
                    game.style.pointerEvents='auto';
                    menu.innerHTML += '<br>CLICK TO PLAY AGAIN';
                }, 1500);
            },
            function(){//During
            }, 
            function(){//Exit
            },
            function(event){//onClick
                gameStateMachine.currentState = gameState.play
            }),
    };
    function resetGame(){
        while(scrollItems.length){ //clear all pipes
            scrollItems[0].remove();
        }
        createPipes(); //create pipe elements
        bird.style.transform = 'translateY(0px)'; //reset bird
        prevYVel = 0;
        fallTime = 0;
        flapTime = 0;
        flapAccel = 0;
        score.score = 0; //reset score
        //reset scroll position
        scrollPos = 0;
        //reset starting space width
        startingSpace.style.minWidth = `${startingSpaceWidth}%`;
        startingSpace.style.width = `${startingSpaceWidth}%`;
    }
    gameStateMachine.currentState = gameState.clickStart;
    function process(){
        gameStateMachine.currentState.duringState();
    }
    setInterval(process, physicsTimeInterval);
</script>
<style>
    #game{
        width: 100%;
        height: 0px;
        background-color: skyblue !important;
        user-select: none;
        padding: 0%;
        margin: 0%;
        display: block;
        overflow: hidden; /*testing*/
    }
    #game .overlay{
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        width: 100%;
        height: 400px;
        background-color: rgba(0, 0, 0, 0.395);
        color: azure;
    }
    #game .prototype{ /*for js cloning obj*/
       display: none !important;
    }
    #game #bird-wrapper{
        position: relative;
        left: 33%;
        display: block;
    }
    #game #bird{
        color: wheat;
        position: absolute;
        background-color: orange !important;
        
        padding: 0px !important;
        height: 30px;
        width: 40px;
        clip-path: ellipse();
        overflow: visible;

        display: block;
        line-height: 30px;
        justify-content: center;
        align-items: center;
        text-align: center;
        
        visibility: hidden;
        outline: rgb(228, 31, 9) 2px solid;
    }
    #game .horizontal-flex{
        position: relative;
        width: 100%;
        height: 100%;
        align-self: center;
        display: flex;
        flex-direction: row;

        /*outline: rgb(35, 10, 7) 2px solid;*/
        /*animation: scroll 9s infinite linear;*/
    }
    #game .vertical-flex{ /*pipe's container*/
        position: relative;
        min-width: 40px;
        display: flex;
        flex-direction: column;
    }
    #game .pipe{
        position: relative;
        background-color: green;
        outline: salmon 2px solid; /*testing*/
    }
    #game .pipe.top{
        flex: 0.5;
    }
    #game .pipe.bot{
        flex: 0.5;
    }
    #game .pipe.gap{ /*Pipe gaps*/
        visibility: hidden;
        flex-basis: 100px;
    }
    #game .spacing{ /*Game gaps*/
        min-width: 40px;
        outline: rgb(234, 250, 114) 2px solid;
    }
    /*@keyframes scroll{ //test anim
        0%{left:100%}
        100%{left:-10%}
    }*/
</style>
</html>